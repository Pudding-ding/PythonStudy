#1.递归函数
#1.1含义
# 一个函数在内部不调用其他的函数，而是调用他本身
#1.2条件
#   1.必须有一个明确的结束条件--递归出口
#   2.每进行更深一层的递归，问题规模相比上次递归都要有所减少
#   3.相邻两次重复之间有紧密的联系
#普通函数实现计算1-100累加和
def add():
    s = 0
    for i in range(1,101):
        s = s + i
        print(s)
add()
#递归函数
# def add2(n):  #要累加到第n项
#     # if n == 1:  #如果是1，就返回1--明确结束条件
#     #     return 1
#     return n + add2(n-1)  #n + add2(n)报错--递归超出最大深度，改变后5+add(4)>5*4+add(3)...有个出口
# print(add2(100))

#斐波那契数列
# 1,1,2,3,5,8,13...
#规律：从第三项开始，每一项都等于前两项之和，即n=(n-2)+ (n-1)
def funa(n):
    if n <= 1:
        return n
    return funa(n-2) + funa(n-1)
print(funa(3))
#1.3 优点
#简洁，逻辑清晰，解题更具有思路
#1.4 缺点
#使用递归函数时需要反复调用函数，耗内存，运行效率低


#2.闭包
#2.1 条件
#   1.函数嵌套（函数里面再定义函数）
#   2.内层函数使用外层函数的局部变量
#   3.外层函数的返回值是内层函数的函数名
def outer():     #外层函数
    n = 10       #外层函数的局部变量
    def inner(): #内层函数
        print(n) #内层函数使用外层函数的局部变量
    #外层函数的返回值是内层函数的函数名
    return inner
# print(outer())   #返回的是内部函数的内存地址
#第一种调用写法
#outer()()
#第二种调用写法
#ot = outer()    #调用外函数
#ot()            #调用内函数

def outer(m):
    n = 10
    def inner():
        print('计算结果：',m+n)
    return inner#发布会函数名而不是inner()是因为inner函数里面参数比较多时或者说受到限制时，写法不太规范
ot = outer(20)  #调用函数
ot()            #调用内函数

#2.2函数引用
def funa():
    print(123)
print(funa) #函数名里面保存了函数所在位置的引用
#id():判断两个变量是否为同一个值的引用
a = 1   #a只不过是一个变量名，存的是1这个数值所在的地址，就是a里面存了数值1的引用
print(a)
print(id(a))
a = 2   #修改a，生成了新的值，重新赋值给变量
print(id(a))
print(id(2))
#内存地址发生变化，因为值也发生了变量
def test1():  #test1也只不过是一个函数名，里面存了这个函数所在位置的引用
    print('这是test函数')
test1()
print(test1)  #内存地址（引用）
te = test1()
te()  #通过引用调用函数

#2.3 每次开启内函数都在使用同一份闭包变量
def outer(m):
    print('outer()函数中的值',m)
    def inner(n):
        print('inner()函数中的值', n)
        return m + n  #在inner函数中返回m+n的值
    return inner
ot = outer(10)  #调用外函数，给outer()传值
#print(ot)
#第一次调用内函数，给inner()传值
print(ot(20))  #调用内函数，给inner()传值
#第二次调用内函数，给inner()传值
print(ot(40)) #10+40
#第三次调用内函数，给inner()传值
print(ot(80)) #10+80

#总结：使用闭包的过程中，一旦外函数被调用异常，返回了内函数的引用，虽然每次调用内函数
#     会开启一个函数，执行后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量

#4.装饰器
# def test02():
#     print('发送消息给丁丁')
# def test():
#     print('开始注册')
#     print('登录')
#     fn()  #调用要传入的函数
# test(test02())
#作用：在不改变原有代码情况下添加新的功能
#条件：
#   1.不修改源程序或函数的代码
#   2.不改变函数或程序的调用方法